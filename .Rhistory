# Filter the columns in the dataset
data_subset <- AirbnbTrain[variables_to_add]
# Convert Superhost to character if it's not already
if ("Superhost" %in% selected_vars && is.numeric(data_subset$Superhost)) {
data_subset$Superhost <- as.character(data_subset$Superhost)
}
# Create the formula
formula <- as.formula(paste(paste(variables_to_add, collapse = " + ")))
# Fit the model
model <- lm(formula, data = data_subset)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Columns to consider as predictors
Y= AirbnbTrain$Price
variables_to_add <- names(AirbnbTrain)[-1]
fits <- lapply(seq_along(variables_to_add), function(x){
lm(paste(log(Y), '~ .'), data = AirbnbTrain[, c(Y, variables_to_add[1:x])])
})
# Columns to consider as predictors
Y <- AirbnbTrain$Price
variables_to_add <- names(AirbnbTrain)[-1]
fits <- lapply(seq_along(variables_to_add), function(x){
predictors <- c("Price", variables_to_add[1:x])
formula_str <- paste("log(", predictors[1], ") ~ .", sep = "")
lm(formula_str, data = AirbnbTrain[, predictors])
})
View(fits)
# Columns to consider as predictors
Y <- AirbnbTrain$Price
variables_to_add <- names(AirbnbTrain)[-1]
fits <- lapply(seq_along(variables_to_add), function(x){
predictors <- c("Price", variables_to_add[1:x])
formula_str <- paste("log(", predictors[1], ") ~ .", sep = "")
lm(formula_str, data = AirbnbTrain[, predictors])
})
mse_list= list()
for (model in fits) {
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
## We need to code Superhost in test as in Training for the predictions to work
AirbnbTest$Superhost<-as.numeric(as.logical(AirbnbTest$Superhost))
# Columns to consider as predictors
Y <- AirbnbTrain$Price
variables_to_add <- names(AirbnbTrain)[-1]
fits <- lapply(seq_along(variables_to_add), function(x){
predictors <- c("Price", variables_to_add[1:x])
formula_str <- paste("log(", predictors[1], ") ~ .", sep = "")
lm(formula_str, data = AirbnbTrain[, predictors])
})
mse_list= list()
for (model in fits) {
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Your initial model
benchFit <- lm(log(Price) ~ 1, data = AirbnbTrain)
# Store the response variable
Y <- AirbnbTrain$Price
# Variables to add
variables_to_add <- c("City", "Day", "Room.Type", "Person.Capacity", "Superhost",
"Multiple.Rooms", "Business", "Cleanliness.Rating", "Guest.Satisfaction",
"Bedrooms", "City.Center..km.", "Metro.Distance..km.",
"Normalised.Attraction.Index", "Normalised.Restraunt.Index")
# Create an empty list to store models and MSE
models <- list()
mse_list <- numeric(length(variables_to_add) + 1)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("log(Y) ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Add MSE for the benchmark model
pred_bench <- predict(benchFit, newdata = AirbnbTest)
mse_bench <- sqrt(mean((pred_bench - log(AirbnbTest$Price))^2))
mse_list[length(mse_list)] <- mse_bench
# Find the model with the lowest MSE
best_model_index <- which.min(mse_list)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", variables_to_add[1:best_model_index], "\n")
cat("MSE of the best model:", mse_list[best_model_index], "\n")
# Store the response variable
Y <- AirbnbTrain$Price
# Variables to add
variables_to_add <- names(AirbnbTrain[-1])
# Create an empty list to store models and MSE
models <- list()
mse_list <- numeric(length(variables_to_add) + 1)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("log(Y) ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Add MSE for the benchmark model
pred_bench <- predict(benchFit, newdata = AirbnbTest)
mse_bench <- sqrt(mean((pred_bench - log(AirbnbTest$Price))^2))
mse_list[length(mse_list)] <- mse_bench
# Find the model with the lowest MSE
best_model_index <- which.min(mse_list)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", variables_to_add[1:best_model_index], "\n")
cat("MSE of the best model:", mse_list[best_model_index], "\n")
# Store the response variable
Y <- AirbnbTrain$Price
# Variables to add
variables_to_add <- names(AirbnbTrain[-1])
# Create an empty list to store models and MSE
models <- list()
mse_list <- numeric(length(variables_to_add) + 1)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("log(Y) ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Add MSE for the benchmark model
mse_list[length(mse_list)] <- MSE_bench
# Find the model with the lowest MSE
best_model_index <- which.min(mse_list)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", variables_to_add[1:best_model_index], "\n")
cat("MSE of the best model:", mse_list[best_model_index], "\n")
library(tidyverse)
library(MASS)
library(caret) #ML tools
library(e1071)
par(mar = c(2, 2, 2, 2))
# Loading and preparing data
Airbnb <- read.csv("Airbnb_data.csv")
Airbnb
# split between training and testing sets
spl = createDataPartition(Airbnb$Price, p = 0.8, list = FALSE)  # 80% for training
AirbnbTrain = Airbnb[spl,]
AirbnbTest = Airbnb[-spl,]
str(AirbnbTrain)
any(is.na(AirbnbTrain))
summary(AirbnbTrain)
boxplot(AirbnbTrain$Price)
AirbnbTrain <- subset(AirbnbTrain, select = -c(Attraction.Index, Restraunt.Index ))
table(AirbnbTrain$City)
table(AirbnbTrain$Day)
table(AirbnbTrain$Room.Type)
table(AirbnbTrain$Shared.Room)
table(AirbnbTrain$Private.Room)
table(AirbnbTrain$Superhost)
table(AirbnbTrain$Multiple.Rooms)
table(AirbnbTrain$Business)
AirbnbTrain <- subset(AirbnbTrain, select = -c(Private.Room, Shared.Room ))
AirbnbTrain$Superhost<-as.numeric(as.logical(AirbnbTrain$Superhost))
ggplot(AirbnbTrain, aes(Price)) + geom_density(fill="lightblue") + xlab("log(Price)") + ggtitle("Price distribution")
## from the statistics obtained before we know price has no 0 values as minimum is 34, so we can apply the logarithm to better visualize it
ggplot(AirbnbTrain, aes(log(Price))) + geom_density(fill="lightblue") + xlab("log(Price)") + ggtitle("Price distribution")
mean(log(AirbnbTrain$Price))
exp(mean(log(AirbnbTrain$Price)))
ggplot(AirbnbTrain, aes(log(Price))) + geom_density(aes(group=City, colour=City, fill=City), alpha=0.1) + ggtitle("Price distribution")
ggplot(AirbnbTrain, aes(x=City.Center..km., y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs City Center distance")
ggplot(AirbnbTrain, aes(x=Metro.Distance..km., y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Metro distance")
ggplot(AirbnbTrain, aes(x = Bedrooms, y = log(Price), fill = City)) +
geom_bar(stat = "identity", position = "dodge", alpha = 0.8) +
ggtitle("Price vs Number of bedrooms")
table(AirbnbTrain$Bedrooms)
ggplot(AirbnbTrain, aes(x=Normalised.Attraction.Index, y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Attraction Index")
ggplot(AirbnbTrain, aes(x=Normalised.Restraunt.Index, y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Restraunt Index")
## Moving the objective function to the last position
AirbnbTrain<-AirbnbTrain[, c(1:(2 - 1), (2 + 1):ncol(AirbnbTrain), 2)]
corr_delay <- sort(cor(AirbnbTrain[,c(4:15)])["Price",], decreasing = T)
corr=data.frame(corr_delay)
ggplot(corr,aes(x = row.names(corr), y = corr_delay)) +
geom_bar(stat = "identity", fill = "lightblue") +
scale_x_discrete(limits= row.names(corr)) +
labs(x = "", y = "Price", title = "Correlations") +
theme(plot.title = element_text(hjust = 0, size = rel(1.5)),
axis.text.x = element_text(angle = 45, hjust = 1))
simple_linFit <- lm(log(Price) ~ Normalised.Attraction.Index, data=AirbnbTrain)
summary(simple_linFit)
# Scatter plot
ggplot(AirbnbTrain, aes(x = Normalised.Attraction.Index, y = log(Price))) +
geom_point(alpha = 0.8, color= 'lightblue') +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
ggtitle("Price vs Attraction Index regression")
pred_simple= exp(predict(simple_linFit, newdata= AirbnbTest))
#Let's know validate the predictions, calculating R^2 in the testing set
R2_simple= cor(pred_simple, AirbnbTest$Price)^2
R2_simple
par(mar = c(2, 2, 2, 2))
plot(simple_linFit, pch=23 ,bg='orange',cex=2)
benchFit <- lm(log(Price) ~ 1, data=AirbnbTrain)
pred_bench <- predict(benchFit, newdata=AirbnbTest)
#MSE comparison: my model vs benchmark
MSE_simple=sqrt(mean((pred_simple - log(AirbnbTest$Price))^2))
MSE_bench= sqrt(mean((pred_bench - log(AirbnbTest$Price))^2))
MSE_simple
MSE_bench
## We need to code Superhost in test as in Training for the predictions to work
AirbnbTest$Superhost<-as.numeric(as.logical(AirbnbTest$Superhost))
# Store the response variable
Y <- AirbnbTrain$Price
# Variables to add
variables_to_add <- names(AirbnbTrain[-1])
# Create an empty list to store models and MSE
models <- list()
mse_list <- numeric(length(variables_to_add) + 1)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("log(Y) ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- predict(model, newdata = AirbnbTest)
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Add MSE for the benchmark model
mse_list[length(mse_list)] <- MSE_bench
# Find the model with the lowest MSE
best_model_index <- which.min(mse_list)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", variables_to_add[1:best_model_index], "\n")
cat("MSE of the best model:", mse_list[best_model_index], "\n")
benchFit <- lm(log(Price) ~ 1, data=AirbnbTrain)
pred_bench <- exp(predict(benchFit, newdata=AirbnbTest))
#MSE comparison: my model vs benchmark
MSE_simple=sqrt(mean((pred_simple - log(AirbnbTest$Price))^2))
MSE_bench= sqrt(mean((pred_bench - log(AirbnbTest$Price))^2))
MSE_simple
MSE_bench
# Store the response variable
Y <- AirbnbTrain$Price
# Variables to add
variables_to_add <- names(AirbnbTrain[-1])
# Create an empty list to store models and MSE
models <- list()
mse_list <- numeric(length(variables_to_add) + 1)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("log(Y) ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE in the list
mse_list[i] <- mse
}
# Add MSE for the benchmark model
mse_list[length(mse_list)] <- MSE_bench
# Find the model with the lowest MSE
best_model_index <- which.min(mse_list)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", variables_to_add[1:best_model_index], "\n")
cat("MSE of the best model:", mse_list[best_model_index], "\n")
View(AirbnbTrain)
View(model)
View(model)
View(model)
View(model)
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add) + 1), Variables = character(length(variables_to_add) + 1), stringsAsFactors = FALSE)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("Y ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE and variables in the data frame
mse_df[i, "MSE"] <- mse
mse_df[i, "Variables"] <- paste(variables_to_add[1:i], collapse = ", ")
}
# Add MSE for the benchmark model
MSE_bench <- sqrt(mean((log(AirbnbTest$Price) - mean(log(AirbnbTrain$Price)))^2))
mse_df[length(mse_df), c("MSE", "Variables")] <- c(MSE_bench, "Benchmark Model")
# Find the model with the lowest MSE
best_model_index <- which.min(mse_df$MSE)
best_model <- models[[best_model_index]]
View(mse_df)
library(tidyverse)
library(MASS)
library(caret) #ML tools
library(e1071)
par(mar = c(2, 2, 2, 2))
# Loading and preparing data
Airbnb <- read.csv("Airbnb_data.csv")
Airbnb
# split between training and testing sets
spl = createDataPartition(Airbnb$Price, p = 0.8, list = FALSE)  # 80% for training
AirbnbTrain = Airbnb[spl,]
AirbnbTest = Airbnb[-spl,]
str(AirbnbTrain)
any(is.na(AirbnbTrain))
summary(AirbnbTrain)
boxplot(AirbnbTrain$Price)
AirbnbTrain <- subset(AirbnbTrain, select = -c(Attraction.Index, Restraunt.Index ))
table(AirbnbTrain$City)
table(AirbnbTrain$Day)
table(AirbnbTrain$Room.Type)
table(AirbnbTrain$Shared.Room)
table(AirbnbTrain$Private.Room)
table(AirbnbTrain$Superhost)
table(AirbnbTrain$Multiple.Rooms)
table(AirbnbTrain$Business)
AirbnbTrain <- subset(AirbnbTrain, select = -c(Private.Room, Shared.Room ))
AirbnbTrain$Superhost<-as.numeric(as.logical(AirbnbTrain$Superhost))
ggplot(AirbnbTrain, aes(Price)) + geom_density(fill="lightblue") + xlab("log(Price)") + ggtitle("Price distribution")
## from the statistics obtained before we know price has no 0 values as minimum is 34, so we can apply the logarithm to better visualize it
ggplot(AirbnbTrain, aes(log(Price))) + geom_density(fill="lightblue") + xlab("log(Price)") + ggtitle("Price distribution")
mean(log(AirbnbTrain$Price))
exp(mean(log(AirbnbTrain$Price)))
ggplot(AirbnbTrain, aes(log(Price))) + geom_density(aes(group=City, colour=City, fill=City), alpha=0.1) + ggtitle("Price distribution")
ggplot(AirbnbTrain, aes(x=City.Center..km., y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs City Center distance")
ggplot(AirbnbTrain, aes(x=Metro.Distance..km., y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Metro distance")
ggplot(AirbnbTrain, aes(x = Bedrooms, y = log(Price), fill = City)) +
geom_bar(stat = "identity", position = "dodge", alpha = 0.8) +
ggtitle("Price vs Number of bedrooms")
table(AirbnbTrain$Bedrooms)
ggplot(AirbnbTrain, aes(x=Normalised.Attraction.Index, y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Attraction Index")
ggplot(AirbnbTrain, aes(x=Normalised.Restraunt.Index, y=log(Price), color=City)) + geom_point(alpha=0.8) + ggtitle("Price vs Restraunt Index")
## Moving the objective function to the last position
AirbnbTrain<-AirbnbTrain[, c(1:(2 - 1), (2 + 1):ncol(AirbnbTrain), 2)]
corr_delay <- sort(cor(AirbnbTrain[,c(4:15)])["Price",], decreasing = T)
corr=data.frame(corr_delay)
ggplot(corr,aes(x = row.names(corr), y = corr_delay)) +
geom_bar(stat = "identity", fill = "lightblue") +
scale_x_discrete(limits= row.names(corr)) +
labs(x = "", y = "Price", title = "Correlations") +
theme(plot.title = element_text(hjust = 0, size = rel(1.5)),
axis.text.x = element_text(angle = 45, hjust = 1))
simple_linFit <- lm(log(Price) ~ Normalised.Attraction.Index, data=AirbnbTrain)
summary(simple_linFit)
# Scatter plot
ggplot(AirbnbTrain, aes(x = Normalised.Attraction.Index, y = log(Price))) +
geom_point(alpha = 0.8, color= 'lightblue') +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
ggtitle("Price vs Attraction Index regression")
pred_simple= exp(predict(simple_linFit, newdata= AirbnbTest))
#Let's know validate the predictions, calculating R^2 in the testing set
R2_simple= cor(pred_simple, AirbnbTest$Price)^2
R2_simple
par(mar = c(2, 2, 2, 2))
plot(simple_linFit, pch=23 ,bg='orange',cex=2)
benchFit <- lm(log(Price) ~ 1, data=AirbnbTrain)
pred_bench <- exp(predict(benchFit, newdata=AirbnbTest))
#MSE comparison: my model vs benchmark
MSE_simple=sqrt(mean((pred_simple - log(AirbnbTest$Price))^2))
MSE_bench= sqrt(mean((pred_bench - log(AirbnbTest$Price))^2))
MSE_simple
MSE_bench
## We need to code Superhost in test as in Training for the predictions to work
AirbnbTest$Superhost<-as.numeric(as.logical(AirbnbTest$Superhost))
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add) + 1), Variables = character(length(variables_to_add) + 1), stringsAsFactors = FALSE)
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("Y ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE and variables in the data frame
mse_df[i, "MSE"] <- mse
mse_df[i, "Variables"] <- paste(variables_to_add[1:i], collapse = ", ")
}
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add) + 1), Variables = character(length(variables_to_add) + 1), stringsAsFactors = FALSE)
models <- list()
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("Y ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE and variables in the data frame
mse_df[i, "MSE"] <- mse
mse_df[i, "Variables"] <- paste(variables_to_add[1:i], collapse = ", ")
}
# Add MSE for the benchmark model
mse_df[length(mse_df), c("MSE", "Variables")] <- c(MSE_bench, "Benchmark Model")
# Find the model with the lowest MSE
best_model_index <- which.min(mse_df$MSE)
best_model <- models[[best_model_index]]
View(mse_df)
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add) + 1), Variables = character(length(variables_to_add) + 1), stringsAsFactors = FALSE)
models <- list()
mse_df[length(mse_df), c("MSE", "Variables")] <- c(MSE_bench, "Benchmark Model")
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("Y ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE and variables in the data frame
mse_df[i, "MSE"] <- mse
mse_df[i, "Variables"] <- paste(variables_to_add[1:i], collapse = ", ")
}
# Add MSE for the benchmark model
# Find the model with the lowest MSE
best_model_index <- which.min(mse_df$MSE)
best_model <- models[[best_model_index]]
View(mse_df)
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add)), Variables = character(length(variables_to_add) + 1), stringsAsFactors = FALSE)
# Store the response variable
Y <- log(AirbnbTrain$Price)
# Variables to add
variables_to_add <- names(AirbnbTrain)[-1]
# Create an empty data frame to store models and MSE
mse_df <- data.frame(MSE = numeric(length(variables_to_add)), Variables = character(length(variables_to_add)), stringsAsFactors = FALSE)
models <- list()
# Fit models and calculate MSE
for (i in seq_along(variables_to_add)) {
formula <- as.formula(paste("Y ~ ", paste(variables_to_add[1:i], collapse = " + ")))
model <- lm(formula, data = AirbnbTrain)
# Store the model
models[[i]] <- model
# Predict on the test set
pred <- exp(predict(model, newdata = AirbnbTest))
# Calculate MSE
mse <- sqrt(mean((pred - log(AirbnbTest$Price))^2))
# Store MSE and variables in the data frame
mse_df[i, "MSE"] <- mse
mse_df[i, "Variables"] <- paste(variables_to_add[1:i], collapse = ", ")
}
# Add MSE for the benchmark model
mse_df[length(mse_df), c("MSE", "Variables")] <- c(MSE_bench, "Benchmark Model")
# Find the model with the lowest MSE
best_model_index <- which.min(mse_df$MSE)
best_model <- models[[best_model_index]]
# Print results
cat("Best model includes variables:", mse_df$Variables[best_model_index], "\n")
cat("MSE of the best model:", mse_df$MSE[best_model_index], "\n")
View(AirbnbTrain)
